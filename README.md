# 훈련 목차
## 1. 알고리즘
### 학습 목표
- 어떤 프로그래밍이던 어느 시점이 되면 필연적으로 방대한 데이터를 다루게 된다.
- 원하는 데이터를 "빨리 찾는 것"이 주요 목적이다.
- 장차 학습할 내용들의 디딤돌이 되지만 실제 처리할 게임 데이터가 아직 없으므로 개론적 수업이 진행됨.
### 학습 내용
- `Template`
  - 고정된 한가지 자료형을 다루는 것이 아닌 정수, 실수, 논리 타입은 물론 객체와 주소도 다룰 수 있다.
    - 자료형의 추상화 - 어떠한 자료형을 다룰지 미리 정해지지 않음
    - 자료형의 다형성 - 자료형이 한가지 고정되어 있지 않고 상황에 따라 변화
    - 자료형의 특수화 - 상속 관계에서 자식의 자료형을 특정하거나 예외처리
- `Linked List`
  - 주로 배열과 비교되는 자료구조로 삽입/삭제에 특화됨
    - 메모리의 단편화 - 연속되지 않은 메모리 공간 할당
    - 데이터의 삽입과 삭제 - 포인터 인덱싱으로 구조의 단순화
    - 시간 복잡도와 공간 복잡도 - 검색의 경우 O^N 복잡도를 지님
- `Stack`
  - LIFO 구조를 갖는 자료구조로 히스토리 추적에 특화됨
    - 콜스택 - 함수의 호출 히스토리와 타임라인
    - 오퍼랜드 - 직렬화된 피연산자와 연산자의 계산 시스템
    - 네비게이션 - 누적된 노드 기반의 경로 시스템
- `Queue`
  - FIFO 구조를 갖는 자료구조로 버퍼링에 특화됨
    - 라우터 - 패킷의 인바운드, 아웃바운드
    - 누적 입력 - 커맨드 및 팩토리 대기열
    - 메세지 - 운영체제의 인터럽트의 순차 처리
- `Tree`
  - 비선형 자료구조로 노드 간 부모, 자식 개념이 존재함
    - 씬 그래프 - 하위 오브젝트의 컬링, 오쿨루전 등 렌더링 관리
    - 최소비용 신장 트리 - 데이터의 흐름을 단방향으로 직렬화
    - 이진 트리 - 정렬의 자동화를 통한 검색 속도 개선
- `Graph`
  - 비선형 자료구조로 단방향, 양방향 통신을 갖는 노드형 구조
    - 스테이트 머신 - 상태에 따른 분기 시스템
    - 우선 탐색 - 깊이 우선, 너비 우선을 통한 자료 검색
    - 경로 시스템 - Prim, Kruskal 등 단초적인 최단 경로 검색
- `Hashing`
  - 공간 복잡도를 희생하여 시간 복잡도를 극대화 시킨 자료구조
    - 이진화 - 비대칭 키를 적용한 암호화 및 압축
    - 시간 복잡도 - 키의 충돌이 없다는 가정하에, O(1) 복잡도를 가짐
    - 공간 복잡도 - 키의 충돌이 발생한 경우 메모리 공간의 확장 필요
- `Devide & Conqure`
  - 동일한 로직으로 데이터를 분산 처리하는 경우 사용하는 Fractal 알고리즘
    - 퀵소트 - 데이터의 시작과 끝 지점이 명확한 경우, 그룹 단위로 쪼개고 합치면서 정렬
    - 정점 쉐이더 - 정점을 레이아웃 단위로 쪼개서 GPU의 멀티스레드 처리
    - 래스터라이저 - 정점의 픽셀화는 정복 구간의 브레즌햄 알고리즘
- `Dynamic Planning`
  - 데이터의 흐름이 연속성을 가질 때 사용하는 일종의 도미노 알고리즘
    - 수열 - Fibonacci, Fractional 등 특정 패턴을 갖는 연속 데이터에 유리
    - 공간의 종속성 - 로컬 공간과 글로벌 공간의 상호작용
    - 본 기반의 애니메이션 - 키프레임과 행렬 데이터의 메타화로 렌더링에 유리
- `Greedy`
  - 최적의 해를 찾기 보다 처리 속도에 중점을 둔 알고리즘
    - A* - Prim, Dijkstra의 처리속도를 개선한 최단 경로 검색
    - 넷코드 : 네트워크 상의 지연을 고려하여 예측 기반의 상태 보간
    - 통계 : 추정치에 대한 가중값 추출
- `Back Tracking`
  - 처리 속도 보다 최적의 해를 찾는 것에 중점을 둔 알고리즘
    - 네비게이션 : 목적 지점이 이미 정해진 경우, 정확한 경로 검색
    - 환경 쿼리 : 오브젝트 간 거리, 시야 차폐, 도달 가능 여부를 추출
    - 통계 : 비선택 된 오답 데이터도 추출 가능
---
## 2. 엔진 프로그래밍
### 학습 목표
- 과거에는 라이선스 비용 절약을 위해 자체 개발 엔진을 사용하였으나 인력 관리의 어려움으로 유지보수가 점차 어려워짐
- 게임 엔진은 프로젝트의 생산성과 각 부처의 협업을 위한 올인원 솔루션을 제공함
- 이미 만들어진 프레임워크를 활용해야 하므로 기술문서를 읽는 법과 내부 소스코드에 대한 분석 과정을 학습
### 학습 내용
- `게임 프레임워크`
  - 상속 구조
    - Actor 계열 - 게임 월드에 배치가 가능한 트랜스폼을 갖는 오브젝트
    - Component 계열 - Actor에게 첨부할 수 있는 서브오브젝트
    - Object 계열 - 월드에 배치되지 않는 관리 및 제어 클래스
  - 게임모드
    - 게임의 룰셋 - 글로벌 혹은 월드에 오버라이딩되는 득점, 실점 등 규칙 선언
    - 서버 역할 - 기본적으로 서버에서만 동작하는 클래스로 서버RPC를 전담한다.
  - 게임인스턴스
    - 시스템 관리 - 플랫폼 및 서브시스템 관리를 담당
    - 상주성 - 레벨이 변경되어도 실행 중에는 상시 상주하는 싱글톤 객체
  - 애니메이션
    - 블렌더블 에셋 - 블렌드스페이스, 에임오프셋, 본 레이어 등을 통한 애니메이션의 합성과 보간
    - 애님인스턴스 - 스테이트머신, 레이어, 본트랜스폼을 통한 최종 출력 애니메이션 관리
    - 리타깃 - 서드파티 캐릭터에 대한 애니메이션 호환성 제공
- `입력 처리`
  - 컨트롤러
    - 플레이어 컨트롤러 - 키보드, 마우스, 게임패드, VR장비 등 입력 장치의 이벤트 관리
    - AI 컨트롤러 - 입력 없이 자율 행동을 하는 오브젝트에게 부여되는 컨트롤러
    - 포제스 - 런타임에서 필요에 따라 입력 기능을 어타치/디태치 가능함
  - 인핸스드 인풋
    - 액션 이벤트 - 지속적인 입력값이 요구되는 무한 반복 입력 이벤트
    - 축 이벤트 - 입력이 있는 경우에만 단발성으로 실행되는 콜백 기반 이벤트
    - 이벤트 기반 처리 - 기본적으로 입력이 감지될 때 재정의가 가능한 딜리게이트가 존재함
- `충돌 처리`
  - 채널 및 반응
    - 오브젝트 채널 - 충돌 처리를 위해 각 오브젝트에게 부여되는 메타 데이터
    - 트레이스 채널 - 범위 기반 충돌 처리를 위해 부여되는 메타 데이터
  - 충돌
    - 콜리전 - 채널에 반응하여 무시, 겹칩, 블로킹 이벤트를 호출하는 컴포넌트
    - 블로킹 - 이벤트 감지 시 해당 지점 이후로 이동을 막는 방식
    - 오버랩 - 이동은 되지만 콜백을 트리거 할 수 있는 방식
  - 트레이스
    - 트레이스 채널 기반 - 카메라와 시야 차폐 여부를 평가한다
    - 오브젝트 채널 기반 - 특정 채널을 갖는 오브젝트만 평가한다
    - 커스터마이징 - 두 채널은 편집이 가능하며 필요 시 추가할 수 있다
  - 물리 엔진
    - 시뮬레이트 - 물리 엔진이 적용되었을 때 반응을 평가한다
    - 충돌 이벤트 - 평가 조건에 의해 물리 엔진 충돌을 평가한다

---
## 3. UI/UX 프로그래밍
### 학습 목표
- 사용자와 상호 작용이 가능한 인터페이스
- 각종 메뉴 외 인벤토리 및 게임 자원의 시각화
- 채팅, 미니맵, 인디케이터 등 다양한 자료 디스플레이
### 학습 내용
- `UMG`
  - 디자인
    - 계층구조 - 위젯 컴포넌트의 종속성을 활용하여 레이아웃을 디자인한다
    - 패널 및 슬롯 - 레이아웃의 방향과 배치 형태에 대한 다양한 템플릿을 지원한다
    - 해상도 - 다양한 디바이스와 해상도에 대한 정렬 기능을 지원한다
  - 공간 변환
    - 화면 공간 - 기본적인 2D 백버퍼 캔버스를 통해 HUD 요소를 표시한다.
    - 월드 공간 - 원근 투영이 적용된 게임 공간 상 좌표에 UI 요소를 표시한다
  - 입력모드
    - 게임온리 - 단지 화면에 표시만 되는 상호작용이 없는 위젯
    - UI온리 - 플레이어 컨트롤러를 화면 공간을 가르키게 하여 위젯만 조작 가능
- `Slate`
  - 모듈
    - 단위 분리 - 프로젝트 내부에 모듈 단위로 추가 플러그인을 작성
    - 에디터 커스터마이징 - 툴바, 디테일패널, 에셋툴 등 에디터 전반 영역의 커스터마이징
- `상호작용`
  - 이벤트 기반
    - 딜리게이트 - UI 요소마다 사전 정의된 딜리게이트를 활용하여 클릭, 커밋, 정규식 검사
    - 바인딩 - UObject 상속 기반 및 Raw, Lamda 등 다양한 형태 적용
    - 직렬성 - C++, 블루프린트 양 측의 이벤트는 모두 호환이 가능한 오버라이더블 및 상호 바인딩이 가능
- `클라이언트 전용`
  - RPC
    - 넷모드 - 특정 사용자를 컨트롤러로 특정하여 해당 사용자에게만 UI 표시
    - 겟모드 - 컨트롤러 및 빙의된 캐릭터에 대한 획득이 용이 
---
## 4. 인공지능 프로그래밍
### 학습 목표
- 직접 조작하지 않는 캐릭터에 대한 로직 부여
- 특정 상황에서 특정 행위를 하도록 작성
- 트리에 기반한 데이터의 흐름
### 학습 내용
- `AI 컨트롤러`
  - 감지 컴포넌트
    - 폰센싱 -
    - 퍼셉션 -
- `네비게이션 메시`
  - 볼륨
    - 네비게이션 메시 볼륨 - 
    - 네비게이션 모디파이 볼륨 -
    - 네비게이션 링크 프록시 -
- `비헤이비어 트리`
  - 메인 노드
    - 컴포짓 -
    - 태스크 -
  - 하위 노드
    - 서비스 -
    - 데코레이터 -
- `블랙보드`
  - 키
    - 멀티 스레드 통신
    - 동기화
- `인바이런먼트 쿼리`
  - 가상 공간
    - 공간 제네레이터 -
    - 테스트 - 스코어 및 필터
---
## 5. 플랫폼 프로그래밍
---
## 6. 그래픽 프로그래밍
---
## 7. 클라이언트 프로그래밍
