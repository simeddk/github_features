기술문서 링크
수업자료 링크
스크린샷 - 결과1, 결과2, 제작1, 제작2

# 훈련 목차
## 1. 알고리즘
### 학습 목표
- 어떤 프로그래밍이던 어느 시점이 되면 필연적으로 방대한 데이터를 다루게 된다.
- 원하는 데이터를 "빨리 찾는 것"이 주요 목적이다.
- 장차 학습할 내용들의 디딤돌이 되지만 실제 처리할 게임 데이터가 아직 없으므로 개론적 수업이 진행됨.
### 학습 내용
- `Template`
  - 고정된 한가지 자료형을 다루는 것이 아닌 정수, 실수, 논리 타입은 물론 객체와 주소도 다룰 수 있다.
    - 자료형의 추상화 - 어떠한 자료형을 다룰지 미리 정해지지 않음
    - 자료형의 다형성 - 자료형이 한가지 고정되어 있지 않고 상황에 따라 변화
    - 자료형의 특수화 - 상속 관계에서 자식의 자료형을 특정하거나 예외처리
- `Linked List`
  - 주로 배열과 비교되는 자료구조로 삽입/삭제에 특화됨
    - 메모리의 단편화 - 연속되지 않은 메모리 공간 할당
    - 데이터의 삽입과 삭제 - 포인터 인덱싱으로 구조의 단순화
    - 시간 복잡도와 공간 복잡도 - 검색의 경우 O^N 복잡도를 지님
- `Stack`
  - LIFO 구조를 갖는 자료구조로 히스토리 추적에 특화됨
    - 콜스택 - 함수의 호출 히스토리와 타임라인
    - 오퍼랜드 - 직렬화된 피연산자와 연산자의 계산 시스템
    - 네비게이션 - 누적된 노드 기반의 경로 시스템
- `Queue`
  - FIFO 구조를 갖는 자료구조로 버퍼링에 특화됨
    - 라우터 - 패킷의 인바운드, 아웃바운드
    - 누적 입력 - 커맨드 및 팩토리 대기열
    - 메세지 - 운영체제의 인터럽트의 순차 처리
- `Tree`
  - 비선형 자료구조로 노드 간 부모, 자식 개념이 존재함
    - 씬 그래프 - 하위 오브젝트의 컬링, 오쿨루전 등 렌더링 관리
    - 최소비용 신장 트리 - 데이터의 흐름을 단방향으로 직렬화
    - 이진 트리 - 정렬의 자동화를 통한 검색 속도 개선
- `Graph`
  - 비선형 자료구조로 단방향, 양방향 통신을 갖는 노드형 구조
    - 스테이트 머신 - 상태에 따른 분기 시스템
    - 우선 탐색 - 깊이 우선, 너비 우선을 통한 자료 검색
    - 경로 시스템 - Prim, Kruskal 등 단초적인 최단 경로 검색
- `Hashing`
  - 공간 복잡도를 희생하여 시간 복잡도를 극대화 시킨 자료구조
    - 이진화 - 비대칭 키를 적용한 암호화 및 압축
    - 시간 복잡도 - 키의 충돌이 없다는 가정하에, O(1) 복잡도를 가짐
    - 공간 복잡도 - 키의 충돌이 발생한 경우 메모리 공간의 확장 필요
- `Devide & Conqure`
  - 동일한 로직으로 데이터를 분산 처리하는 경우 사용하는 Fractal 알고리즘
    - 퀵소트 - 데이터의 시작과 끝 지점이 명확한 경우, 그룹 단위로 쪼개고 합치면서 정렬
    - 정점 쉐이더 - 정점을 레이아웃 단위로 쪼개서 GPU의 멀티스레드 처리
    - 래스터라이저 - 정점의 픽셀화는 정복 구간의 브레즌햄 알고리즘
- `Dynamic Planning`
  - 데이터의 흐름이 연속성을 가질 때 사용하는 일종의 도미노 알고리즘
    - 수열 - Fibonacci, Fractional 등 특정 패턴을 갖는 연속 데이터에 유리
    - 공간의 종속성 - 로컬 공간과 글로벌 공간의 상호작용
    - 본 기반의 애니메이션 - 키프레임과 행렬 데이터의 메타화로 렌더링에 유리
- `Greedy`
  - 최적의 해를 찾기 보다 처리 속도에 중점을 둔 알고리즘
    - A* - Prim, Dijkstra의 처리속도를 개선한 최단 경로 검색
    - 넷코드 : 네트워크 상의 지연을 고려하여 예측 기반의 상태 보간
    - 통계 : 추정치에 대한 가중값 추출
- `Back Tracking`
  - 처리 속도 보다 최적의 해를 찾는 것에 중점을 둔 알고리즘
    - 네비게이션 : 목적 지점이 이미 정해진 경우, 정확한 경로 검색
    - 환경 쿼리 : 오브젝트 간 거리, 시야 차폐, 도달 가능 여부를 추출
    - 통계 : 비선택 된 오답 데이터도 추출 가능
---
## 2. 엔진 프로그래밍
### 학습 목표
- 과거에는 라이선스 비용 절약을 위해 자체 개발 엔진을 사용하였으나 인력 관리의 어려움으로 유지보수가 점차 어려워짐
- 게임 엔진은 프로젝트의 생산성과 각 부처의 협업을 위한 올인원 솔루션을 제공함
- 이미 만들어진 프레임워크를 활용해야 하므로 기술문서를 읽는 법과 내부 소스코드에 대한 분석 과정을 학습
- 이 단계에서는 엔진 사용 초기 단계로서, 복잡한 기하학을 다루는걸 최대한 지양하고 사이드스크롤 게임을 만든다.
### 학습 내용
- `게임 프레임워크`
  - 상속 구조
    - Actor 계열 - 게임 월드에 배치가 가능한 트랜스폼을 갖는 오브젝트
    - Component 계열 - Actor에게 첨부할 수 있는 서브오브젝트
    - Object 계열 - 월드에 배치되지 않는 관리 및 제어 클래스
  - 게임모드
    - 게임의 룰셋 - 글로벌 혹은 월드에 오버라이딩되는 득점, 실점 등 규칙 선언
    - 서버 역할 - 기본적으로 서버에서만 동작하는 클래스로 서버RPC를 전담한다.
  - 게임인스턴스
    - 시스템 관리 - 플랫폼 및 서브시스템 관리를 담당
    - 상주성 - 레벨이 변경되어도 실행 중에는 상시 상주하는 싱글톤 객체
  - 애니메이션
    - 블렌더블 에셋 - 블렌드스페이스, 에임오프셋, 본 레이어 등을 통한 애니메이션의 합성과 보간
    - 애님인스턴스 - 스테이트머신, 레이어, 본트랜스폼을 통한 최종 출력 애니메이션 관리
    - 리타깃 - 서드파티 캐릭터에 대한 애니메이션 호환성 제공
- `입력 처리`
  - 컨트롤러
    - 플레이어 컨트롤러 - 키보드, 마우스, 게임패드, VR장비 등 입력 장치의 이벤트 관리
    - AI 컨트롤러 - 입력 없이 자율 행동을 하는 오브젝트에게 부여되는 컨트롤러
    - 포제스 - 런타임에서 필요에 따라 입력 기능을 어타치/디태치 가능함
  - 인핸스드 인풋
    - 액션 이벤트 - 지속적인 입력값이 요구되는 무한 반복 입력 이벤트
    - 축 이벤트 - 입력이 있는 경우에만 단발성으로 실행되는 콜백 기반 이벤트
    - 이벤트 기반 처리 - 기본적으로 입력이 감지될 때 재정의가 가능한 딜리게이트가 존재함
- `충돌 처리`
  - 채널 및 반응
    - 오브젝트 채널 - 충돌 처리를 위해 각 오브젝트에게 부여되는 메타 데이터
    - 트레이스 채널 - 범위 기반 충돌 처리를 위해 부여되는 메타 데이터
  - 충돌
    - 콜리전 - 채널에 반응하여 무시, 겹칩, 블로킹 이벤트를 호출하는 컴포넌트
    - 블로킹 - 이벤트 감지 시 해당 지점 이후로 이동을 막는 방식
    - 오버랩 - 이동은 되지만 콜백을 트리거 할 수 있는 방식
  - 트레이스
    - 트레이스 채널 기반 - 카메라와 시야 차폐 여부를 평가한다
    - 오브젝트 채널 기반 - 특정 채널을 갖는 오브젝트만 평가한다
    - 커스터마이징 - 두 채널은 편집이 가능하며 필요 시 추가할 수 있다
  - 물리 엔진
    - 시뮬레이트 - 물리 엔진이 적용되었을 때 반응을 평가한다
    - 충돌 이벤트 - 평가 조건에 의해 물리 엔진 충돌을 평가한다

---
## 3. UI/UX 프로그래밍
### 학습 목표
- 사용자와 상호 작용이 가능한 인터페이스
- 각종 메뉴 외 인벤토리 및 게임 자원의 시각화
- 채팅, 미니맵, 인디케이터 등 다양한 자료 디스플레이
- 이 단계에서는 게임에 적용되는 메인메뉴, 포즈메뉴, 스테이지 선택, 승리/패배 메뉴 등을 다룬다.
### 학습 내용
- `UMG`
  - 디자인
    - 계층구조 - 위젯 컴포넌트의 종속성을 활용하여 레이아웃을 디자인한다
    - 패널 및 슬롯 - 레이아웃의 방향과 배치 형태에 대한 다양한 템플릿을 지원한다
    - 해상도 - 다양한 디바이스와 해상도에 대한 정렬 기능을 지원한다
  - 공간 변환
    - 화면 공간 - 기본적인 2D 백버퍼 캔버스를 통해 HUD 요소를 표시한다.
    - 월드 공간 - 원근 투영이 적용된 게임 공간 상 좌표에 UI 요소를 표시한다
  - 입력모드
    - 게임온리 - 단지 화면에 표시만 되는 상호작용이 없는 위젯
    - UI온리 - 플레이어 컨트롤러를 화면 공간을 가르키게 하여 위젯만 조작 가능
- `Slate`
  - 모듈
    - 단위 분리 - 프로젝트 내부에 모듈 단위로 추가 플러그인을 작성
    - 에디터 커스터마이징 - 툴바, 디테일패널, 에셋툴 등 에디터 전반 영역의 커스터마이징
- `상호작용`
  - 이벤트 기반
    - 딜리게이트 - UI 요소마다 사전 정의된 딜리게이트를 활용하여 클릭, 커밋, 정규식 검사
    - 바인딩 - UObject 상속 기반 및 Raw, Lamda 등 다양한 형태 적용
    - 직렬성 - C++, 블루프린트 양 측의 이벤트는 모두 호환이 가능한 오버라이더블 및 상호 바인딩이 가능
- `스타일라이징`
  - 코스매틱 - 머티리얼 및 텍스쳐 제어를 통해 화려한 효과 및 게이지 이펙트 등을 표현
  - 애니메이션 - 선형보간이 적용된 템플릿 타입의 키 프레임을 통한 각종 효과
  - 메뉴스위처 - 단일 위젯 내에서 메뉴 간 전환 등 요소 제어
- `클라이언트 전용`
  - RPC
    - 넷모드 - 특정 사용자를 컨트롤러로 특정하여 해당 사용자에게만 UI 표시
    - 겟모드 - 컨트롤러 및 빙의된 캐릭터에 대한 획득이 용이 
---
## 4. 인공지능 프로그래밍
### 학습 목표
- 직접 조작하지 않는 캐릭터에 대한 로직 부여
- 특정 상황에서 특정 행위를 하도록 작성
- 트리에 기반한 데이터의 흐름
- 이 단계에서는 언리얼 오브젝트 베이스의 다양한 프레임워크의 사용법을 익힌다
### 학습 내용
- `AI 컨트롤러`
  - 감지 컴포넌트
    - 폰센싱 - 시야, 청각 등 감지 영역을 통한 주변 액터의 인지 기능
    - 퍼셉션 - 팀ID에 기반한 폰센싱의 상위 개념
- `네비게이션 메시`
  - 볼륨
    - 네비게이션 메시 볼륨 - 최단 거리 측정이 가능한 노드 기반의 길찾기 시스템
    - 네비게이션 모디파이 볼륨 - 데드 아일랜드 등 고립된 지역에서의 길찾기를 제한할 수 있는 볼륨
    - 네비게이션 링크 프록시 - 단절된 볼륨 사이를 이동할 수 있게 하는 경로 제공
- `비헤이비어 트리`
  - 메인 노드
    - 컴포짓 - 하위 노드들의 성공, 실패 여부를 통해 이후 진행 여부를 결정하는 분기문
    - 태스크 - 실제 수행되는 액션으로 이동, 공격, 무기 장착 등 성공, 실패를 갖는 노드
  - 하위 노드
    - 서비스 - 블랙보드에 값을 읽고 쓰거나 주기를 갖는 보조 태스크의 역할을 갖는 노드
    - 데코레이터 - 하위 노드의 관찰자 중단을 수행하는 분기문으로 하위 노드를 강제 종료시킬 수 있다
- `인바이런먼트 쿼리`
  - 가상 공간
    - 공간 제네레이터 - 그리드, 도넛, 서클 등 다양한 형태의 아이템을 배치하는 네비게이션 기반의 시스템
    - 테스트 - 스코어 및 필터를 적용하여 각 아이템에 유의미한 점수를 부여하며, 최고 점수 노드를 계산하기 위함
    - 쿼리어 컨텍스트 - 각종 공간에서 중심점 및 기준점이 되는 위치 혹은 액터를 정의하는 클래스
---
## 5. 플랫폼 프로그래밍
### 학습 목표
- 개발에 있어 다양한 설계와 구성, 방법론을 다룬다
- 실무에 적용 가능한 다양한 프레임워크를 구사하고 특별히 주의할 사항을 배운다
- 언리얼에서 권장하는 모범 사례를 분석하고 기술 문서 열람 및 디버깅을 심층적으로 익힌다
- 게임에서 많이 사용되는 기하학과 선형 대수학을 프로젝트에 적용한다
- 이 단계에서는 개발에 전반적인 심화적인 내용을 배운다.
### 학습 내용
- `Is-A`
  - 상속 구조 - 부모 클래스의 기능을 유지하거나 재정의를 통해 일관성과 관리 포인트를 줄임
  - 인터페이스 - 동일한 함수를 갖는 타입 끼리 기능 단위의 그룹핑을 가능하게 하며, 연관성이 적은 클래스 간 역참조가 가능
  - 다형성 - 자식 클래스는 모든 부모 클래스의 유형을 포함하고 있으며 캐스팅을 통해 특정 유형에 접근할 수 있다
- `Has-A`
  - 서브오브젝트 - 일반적으로 컴포넌트라고 부르는 유형으로, 거대 클래스를 기능 단위로 
  - 오너쉽 - 소유자를 특정하는 것으로 논리적 거리가 먼 주소끼리 통신이 가능하게 된다
  - 재활용 - 상속과 달리 불필요한 재정의가 없으며 부모와 상관없이 필요한 곳에만 적용, 재활용이 가능하다
- `데이터`
  - DDD - 사전에 정의된 데이터를 기반으로 설계 구조를 설정하는 개발 방법론
  - 데이터 곤리 - 데이터에셋, 데이터테이블은 정규화된 데이터 포맷과 호환이 되며, 네트워크에서도 유용하다
  - 파일 관리 - 영구적 데이터 보관을 위해 다양한 포맷의 플레인 텍스트는 물론 바이너리 파일로도 저장할 수 있다
- `타이머`
  - 타이머 이벤트 - 별도의 핸들러를 갖는 멀티스레드 이벤트를 구현하여 메인 루틴에 영향 없이 이벤트의 딜레이를 걸 수 있다
  - 타임라인 - 보간 적용을 받는 커브 에셋을 활용하여 시간에 흐름에 따른 스칼라, 벡터, 컬러 등 다양한 출력값을 얻는다
- `수학`
  - 벡터의 내적과 외적 - 방향의 일치성과 투영벡터의 길이를 구하는데 특히 유효하며, 직교화를 통해 렌더링 등 축계산에 응용됨
  - 노멀벡터와 탄젠트벡터 - 램버트에 의한 음영 처리, 노멀맵핑, 충돌 처리, 포스트 프로세스 등 유용한 메타 데이터
  - 삼각함수 - 회전과 방향값을 상호 변환할 수 있으며 상하 판단, 밟고 있는 지면의 축 보정 등에 유용하다
  - 행렬 - 위치, 회전, 크기의 벡터 정보를 단일 타입으로 묶음으로서 공간에 대한 종속성을 부여할 수 있다
  - 보간 - 선형, 3차 큐빅, 스테이블, 슬러프 등 게임에서 사용되는 각종 보간 방법
- `메타데이터`
  - 게임플레이 태그 - 수많은 불린 타입과 이넘 타입을 대체하는 해싱 알고리즘의 문자열 집합. 상태와 변수 관리에 유연성이 높아진다
  - 동적 어빌리티 - 레벨 및 지역 이동에 따른 해금, 약점 및 내성의 부여 등 게임 플레이 도중에 언제나 적용 가능하며 호환성이 높은 방법론
- `레퍼런스`
  - 하드 레퍼런스 - 에셋이 로드될 때 참조되는 모든 에셋을 빌드 타임에 올리는 것으로, 런타임 로딩은 없으나 공간 낭비가 심한 방식
  - 소프트 레퍼런스 - 필요에 의해 동적으로 에셋을 로드하는 방식으로 빌드 타임이 향상되나 플레이 도중 잔랙을 유발시킨다
  - 에셋 매니저 - 소프트 레퍼런스가 적용된 에셋들을 관리하는 ID 기반의 관리 시스템
- `최적화`
  - 분석 도구
    - 인사이트 - 북마크를 기반으로 한 이벤트의 추적 및 지연, 동작 시간, 콜스택 등을 비주얼라이저로 표시하는 시스템
    - 스테이트 콘솔 명령어 - 하드웨어 및 코드의 동작 상태를 실시간으로 체크할 수 있는 게임 플레이 명령어 시스템
    - PSO - 쉐이더의 컴파일 결과를 사전에 메모리로 로드시켜 GPU의 연산량을 줄이는 최적화 기법
  - 패키징
    - 컬처 - 현지화 텍스트를 통해 추가된 언어에 대한 번역 기능을 제공함
    - 포함 에셋 - 빌드에 필요한 에셋을 델타 백업 기법으로 포함하거나 제외시킬 수 있다
    - 빌드 타깃 - 패키징하고자 하는 플랫폼에 따라 구성관리자를 변환할 수 있는 클래스
---
## 6. 그래픽 프로그래밍
### 학습 목표
- 화면에 한 한장의 프레임이 그려지기 까지 동작 원리를 이해하고 직접 실습한다
- 렌더링 파이프라인의 대표적인 각 스테이지를 익힌다
- 엔진에 적용되었던 각종 렌더링의 기술적 요소를 직접 작성한다
- GPU와 vRam에 적용되는 그래픽스 프로그래밍 코드를 작성한다
- 이 단계에서는 그래픽의 품질 향상과 최적화에 대해 학습한다
### 학습 내용
- `자원 관리`
  - SRV - 쉐이더에거 보여줄 자원들을 파이프라인에 관계없이 밀어줄 수 있다. 주로 텍스처를 전송한다
  - UAV - GPU에서 멀티스레드로 처리한 결과를 다시 CPU와 메모리로 불러올 수 있다
  - 스왑체인 - 화면의 플리커를 없애기 위해 렌더링 처리가 완료된 백버퍼 텍스처를 전환할 때 사용한다
  - 뷰포트 - 디바이스 특유의 해상도가 적용된 백버퍼 뷰어 화면으로 주로 게임 화면을 담당한다
  - 디바이스 - 렌더링 파이프라인에 사용되는 각종 자원을 생성하거나 해제한다
  - 디바이스 컨텍스트 - 생성된 자원을 렌더링 파이프라인의 각 스테이지에 연동시키는 역할을 한다
- `렌더링 파이프라인`
  - 입력 조립
    - 정점 버퍼 - 직접 생성하거나 모델에서 로드된 정점 데이터를 GPU에서 연산할 수 있는 직렬화 데이터를 만든다
    - 인덱스 버퍼 - 정점의 두르기 순서를 고려하여 대량의 정점 데이터가 그려질 순서를 제어한다
    - 상수 버퍼 - 정점에는 포함되지 않지만 렌더링에 필요한 추가적인 데이터를 전송한다. 바이트 크기에 민감하다
  - 정점 쉐이더
    - 인풋 레이아웃 - 각 정점을 GPU의 멀티스레드가 처리할 수 있도록 분리가 되는 기준 바이트 크기를 계산한다
    - 월드 공간 변환 - 게임 플레이가 진행되는 3D 공간 상의 원하는 위치, 회전, 크기를 반영한다
    - 뷰 공간 변화 - 화면에는 시야 제한이 있기 때문에 카메라에 상대적인 위치를 계산하며 그릴 범위를 반영한다
  - 헐 쉐이더
    - 정점의 추가 분할 - 정점의 개수를 줄여 더 넓은 대역폭을 확보하기 위해 일부 정점은 GPU에서 새로 그린다
    - 무게중심 - 사전에 정의된 패턴을 적용하기 위해 폴리곤을 분할할 중심점을 구한다
    - 간선 - 몇 개를 기준으로 새로운 폴리곤을 나눌지 기준값을 정한다
  - 테셀레이션 -
    - 프랙탈 패턴 - 절차적인 프로토콜에 의해 GPU에서 계산된 정점들을 실제로 쪼개는 역할을 담당한다
    - LOD - 카메라와 멀리 떨어진 오브젝트는 원근 투영에 의해 작아지므로, 많은 양의 정점을 할당할 필요가 없다
  - 도메인 쉐이더
    - 분할 정점의 병합 - 테셀레이션에 의해 분할된 정점들을 이 스테이지에서 다시 병합한다
    - 분할 정점의 공간 변환 - 기존의 정점 쉐이더에서 계산하지 않은 신규 정점들의 위치 정보를 다시 잡아준다
  - 기하 쉐이더
    - 정점의 추가 - vRam 대역폭을 절약하기 위해 1개의 정점을 최대 8개로 분리한다
    - GPU 컬링 - 정점을 폐기함으로서 면의 성립 방해하는 컬링이 적용된다
  - 스트림 출력
    - 정점의 병합 - 픽셀이 되기 직전까지 처리된 데이터를 다시 스트림으로 태울 수 있다
    - IA 스테이지로 리턴 - GPU의 처리 결과를 다시 CPU로 받아온다. 충돌을 다시 계산하거나 텍스쳐를 만들 때 사용한다
  - 래스터라이저
    - 선형 보간 - 브렌슨햄 알고리즘에 의해 정점 간 보간을 진행하며, 정점의 모든 메타데이터는 보간이 발생한다
    - 컬링 - 두르기 순서에 의한 컬링 및 뒷면 컬링이 발생한다. 시야 차폐된 불필요한 픽셀을 추려낸다
  - 픽셀 쉐이더
    - 머티리얼 - 각 픽실에 입혀질 컬러 정보를 작성할 수 있다
    - 샘플링 - 정점에 심어진 UV0 좌표를 활용하여 이미지의 RGB 채널값을 읽어 온다
    - 라이팅 - 램버트, 노멀맵핑, 앰비언트, 스펙큘러, 이미시브는 물론 반사, 굴절 등 질감 표현에 필요한 픽셀값을 계산
    - 멀티 렌더타깃 - 백버퍼를 다수의 렌더타깃에 나눠 담아 추가적인 패스에서 이 정보를 활용할 수 있게 해준다
  - 출력 병합
    - 렌더타깃 - 픽셀 쉐이더에 의해 그려진 컬러 정보를 저장하는 자원이다. 백버퍼 텍스쳐와 연결되어 있다
    - 뎁스스텐실 - 래스터라이저에서 차폐된 픽셀 정보를 바탕으로 카메라까지의 거리를 0~1사이의 언노멀값으로 갖는 텍스쳐
    - 알파 블렌드 - 백버퍼에 모든 액터가 그려진 상태에서 상호 색상에 대한 반투명 처리를 하거나 마스킹을 적용한다
- `컴퓨트 쉐이더`
  - Raw 버퍼 - 1차원 바이너리 데이터를 CS로 전송할 때 사용한다
  - Structured 버퍼 - Raw 버퍼와 유사하나 데이터의 크기가 단일 데이터가 아닐 때 사용한다
  - Texture 버퍼 - 2차원 이상의 데이터를 테이블의 형태로 전송할 때 사용한다
- `디퍼드 렌더링`
  - GBuffer - 다수의 렌더타깃에 저장된 월드 노멀, 앰비언트 오쿨루전 등 전용 정보를 저장하는 텍스쳐를 생성한다
  - 포스트렌더 - 라디얼 블러, 가우시안 블러, 블룸, 비넷, 인터레이스, 컬러그레이딩 등 전반적인 코스매틱 렌더링에 사용
  - 게임이펙트 - 소드 트레인, 오쿨루전 버퍼, 카툰 렌더링, 스피어 마스크, 디졸브 등 각종 게임 이펙트
  - 깊어 버퍼 - 그림자를 계산하기 위해 조명 관점에서 작성된 깊이 정보이다. 메인 렌더링과 깊이 차이를 이용한다
- `프리넬`
  - 반사와 굴절 - 별도의 캡쳐 액터를 사용하여 촬영된 텍스처 정보를 다음 패스에서 샘플링
  - 다이나믹 큐브맵 - 월드 공간에서 캡쳐된 텍스쳐를 런타임에서 샘플링하여 거울이나 물결 등 고반사 액터에 적용한다
  - 대기산란 - 레일리 산란과 미 산란을 적용하여 시간대별로 발생하는 실제와 같은 태양광 및 하늘의 색상을 계산한다
- `모델`
  - 임포트 - FBX, OBJ 등 디자이너가 작성한 모델 정보를 프로젝트에 알맞는 형태로 컨버팅
  - 렌더링 - 본 구조를 갖는 모델을 렌더링할 때, 계층화된 공간 종속성을 적용하며 컨버팅된 정보를 쉐이더에 투영
  - 애니메이션 - 키프레임, 본 번호, 클립 번호를 3차원 텍스쳐로 저장하여 GPU에서 렌더링
  - 보간 - 행렬로 구성되었기 때문에 프레임 간 보간, 동작 간 보간, 레이어에 의한 보간이 가능하다
---
## 7. 클라이언트 프로그래밍
### 학습 목표
- 실제 인터넷 환경에서 동작하는 멀티플레이 게임을 제작한다
- 서버, 클라이언트 모델의 동작 방식을 이해하고 게임에 적용한다
- 이벤트와 상태에 대한 유저 간 동기화를 유지한다
- 네트워크의 기본 개념을 이해하고 데이터를 패킷으로 송수신 및 처리한다
- 이 단계에서는 멀티플레이 환경 전반에 걸친 CS 지식을 학습한다
### 학습 내용
- `서버 - 클라이언트 모델`
  - 권한자
    - 상태 처리 - 모든 상태의 처리는 치팅 방지, 동기화 유지를 위해 서버에서 처리하는 것을 기본 원칙으로 한다
    - 액터의 복제 - 서버에서 동일한 트랜스폼을 갖는 사본을 클라이언트에게 생성
    - 컨트롤러의 복제 - 서버와 로컬 유저에게 각각 하나씩 복제되므로 특정 유저 단위로 식별하기 용이함
    - 게임 상태의 복제 - 서버에서 사용되는 타임, 유저 리스트 등 각종 정보를 배열로 저장하는 클래스
    - 플레이어 상태의 복제 - 플레이어 캐릭터는 라이프 사이클을 가지므로 사망 및 리스폰 시에도 상태가 유지되는 클래스가 필요함
    - 관계성 - 모든 플레이어가 액터에 접근할 필요가 없으므로, 어디까지 복제해야 할지 범위를 결정한다
    - 넷 컬 - 액터와 플레이어 간 거리가 너무 멀 경우 패킷에 태울 필요가 없다
- `네트워크 복제`
  - 변수의 복제
    - 서버 처리 - 변수의 복제는 서버에서 클라이언트로만 가능하며 반대의 경우는 불가능하다
    - 클라이언트의 수신 - 서버에서 변경된 값을 읽기 전용으로 다운로드만 받는다. 클라이언트는 서버의 결과를 시뮬레이트 한다
  - 함수의 원격 호출
    - 서버 콜 - 입력 장치는 로컬에 있기 때문에 정보를 서버로 업로드 후 상태 처리를 하도록 해야 한다
    - 클라이언트 콜 - 서버에서 처리된 결과를 특정 유저에게만 보여줘야 할 필요가 있다
    - 넷멀티캐스트 콜 - 서버와 클라이언트 모두에게 발생하는 함수이다. 여기서 모두는 나를 제외한 다른 유저들이 포함된다
  - 오브젝트와 컴포넌트의 복제
    - 복제 조건의 정규화 - 액터보다 상위 클래스는 기본적으로 복제 기능이 없지만 상태가 변경될 때 콜백을 실행할 수 있다
    - 구성 요소의 정규화 - 액터가 포함된 모든 컴포넌트는 기본적으로 복제가 되지 않지만 필요 시 이를 수행할 수 있다
- `역할`
  - 로컬 롤
    - 권한자 - 서버에 존재하는 모든 플레이어는 기본적으로 상태 변경에 대한 권한을 갖는다
    - 자율 프록시 - 로컬이 직접 제어하는 플레이어를 지칭하며 다른 플레이어와 구별된다
    - 시뮬레이트 프록시 - 내가 직접 제어하지 않는, 상대방 측 자율 프록시이다
  - 리모트 롤
    - 권한자 - 기본적으로 모든 클라이언트가 받는 리모트 롤은 권한자이다
    - 자율 프록시 - 호스트 유저 자신을 제외한 모든 리모트 롤은 자율 프록시이다
    - 시뮬레이트 프록시 - 호스트 유저 자신의 리모트 롤이 시뮬레이트 프록시이다. 이는 호스트 유저를 식별할 때 사용된다
- `온라인 서브 시스템`
  - 서브시스템 인터페이스
    - 플랫폼 - 로컬 네트워크 환경에서 테스트할 수 있는 널 서브시스템 외에도 스팀 등 외부 OSS를 적용할 수 있다
    - 세션인터페이스
      - 세션의 생성 - 방의 제목, 참여 인원, 초대 슬롯 등을 결정하여 같이 플레이할 유저들이 접근할 수 있는 공간을 만든다
      - 세션의 삭제 - 세션 생성 시 중복 세션이 존재하는 경우 이를 삭제하고 재생성한다
      - 세션의 검색 - 현재 공개되어 있는 세션들에 대한 검색 결과를 배열로 받을 수 있다
      - 세션의 참여 - 검색된 결과를 바탕으로 선택해서 조인하거나 직접 IP주소, URL 등을 통해 접근할 수 있다
      - 게임의 시작 - 이미 게임이 시작된 세션에는 다른 유저가 참여할 수 없어야 한다
      - 연결 실패 예외 처리 - 세션이 끊어진 후의 이벤트를 처리할 수 있으며 실패 원인에 대한 메세지를 기록할 수 있다
    - 친구 상태 및 외부 UI - OSS에서 제공하는 프리즌스 기능을 적용한다
